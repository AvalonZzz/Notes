## 箭头函数

箭头函数的括号在只有一个参数的时候可以省略

箭头函数的函数体如果没有大括号则只能有一条语句，并且会隐式返回这条语句的值

**箭头函数不能使用`arguments`、`super`和`new.target`，也不能用作构造函数。箭头函数也没有prototype属性**

## 函数名

所有函数对象都会暴露一个只读的name属性。

- 大多情况保存的是函数标识符
- 如果是Function构造函数创建，则会标识为`"anonymous"`
- 如果函数是一个获取函数、设置函数或者使用`bind()`实例化，则会在标识符前面加一个前缀

```js
function foo(){}
let bar = function() {}
let baz = () => {}
console.log(foo.name) // foo
console.log(bar.name) // bar
console.log(baz.name) // baz
console.log((() => {}).name) // 空字符串
console.log((new Function()).name) // anonymous

function foo() {}
console.log(foo.bind(null).name) // bound foo
let dog = {
	years: 1,
	get age(){
		return this.years
	},
	set age(newAge){
		this.years = newAge
	}
}
let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age')
console.log(propertyDescriptor.get.name); // get age 
console.log(propertyDescriptor.set.name); // set age
```

## 理解参数

定义函数时接收的参数个数和调用函数时传的参数个数不需要一致

`arguments`对象是一个类数组，可用中括号语法访问其中元素，可用length属性确定参数个数

```js
function sayHi(name, message) {
	console.log('hello'+name+','+message)
}
// 重写，即使没有命名参数，通过arguments依然可以接收到参数
function sayHi() {
	console.log('hello'+arguments[0]+','+arguments[1])
}
```

`arguments`的值会始终和对应的命名参数同步

```js
function doAdd(num1, num2) {
  arguments[1] = 10
  console.log(arguments[0]+num2)
}
doAdd(1, 2) // 11
```

如果函数是箭头函数定义的，那么传给函数的参数不能使用arguments关键字访问，但是可以在包装函数中把它提供给箭头函数

```js
function foo() {
  let bar = () => {
    console.log(arguments[0]) // 5
  }
  bar()
}
foo(5)
```

>  `ECMAScript` 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作 为参数传递，那么传递的值就是这个对象的引用。

## 默认参数值

函数的参数值等于undefined的时候就会采用默认值

```js
function makeKing(name = 'Henry'){
	return `King ${name} VIII`
}
console.log(makeKing('Louis')) // King Louis VIII
console.log(makeKing()) // King Henry VIII
```

**函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值**

### 默认参数作用域与暂时性死区

给多个参数定义默认值实际上跟使用let声明变量一样，默认参数会按照定义顺序依次被初始化

```js
function makeKing(name='Henry', numerals='VIII'){
	return `King ${name} ${numerals}`
}
// 等同于下面
function makeKing(){
    let name='Henry'
    let numerals = 'VIII'
    return `King ${name} ${numerals}`
}
```

默认参数初始化顺序遵循暂时性死区规则，即前面定义的参数不能引用后面定义的

```js
// 调用函数时不传第一个参数会报错
function makeKing(name=numerals, numerals='VIII'){
	return `King ${name} ${numerals}`
}
// 后面的参数引用前面的定义可以
function makeKing(name='Henry', numerals=name){
	return `King ${name} ${numerals}`
}
```

**默认参数有自己的作用域，不能引用函数体的作用域**

```js
// 调用函数不传第二个参数会报错
function makeKing(name='Henry',numerals=defaultNumeral) {
	let defaultNumeral = 'VIII'
	return `King ${name} ${numerals}`
}
```

## 参数扩展和收集

### 扩展参数

`...`扩展操作符可将可迭代对象平铺成一组数据

```js
let values = [1,2,3,4]
function countArguments() {
	console.log(arguments.length)
}
countArguments(-1, ...values) // 5
```

### 收集参数

使用扩展操作符把不同长度的独立参数组合为一个数组

```js
function getSum(...values){
	return values.reduce((x, y) => x + y, 0)
}
console.log(getSum(1, 2, 3)) // 6, values的结果为[1, 2, 3]
```

收集参数前面如果还有命名参数，则只会收集其余的参数；收集参数只能作为最后一个形参

```js
// 不可以
function getProduct(...values, lastValue){}
// 可以
function getProduct(firstValue, ...values){}
// 箭头函数可用收集参数来实现arguments功能
let getSum = (...values) => {
    return values.reduce((x, y) => x + y, 0)
}
console.log(getSum(1, 2, 3)) // 6
```

使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数

```js
function getSum(...values) { 
 console.log(arguments.length); // 3 
 console.log(arguments); // [1, 2, 3] 
 console.log(values); // [1, 2, 3] 
} 
getSum(1, 2, 3)
```

## 函数声明和函数表达式

JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中 生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。

```js
// 没问题 
console.log(sum(10, 10)); 
function sum(num1, num2) { 
 return num1 + num2; 
} 
// 会出错
console.log(sum(10, 10)); 
let sum = function(num1, num2) { 
 return num1 + num2; 
}; 
```

> 在执行代码时，JavaScript 引擎会先执行一遍扫描， 把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把 函数声明提升到顶部。

## 函数内部

### arguments

arguments对象是一个类数组对象，包含调用函数时传入的所有参数

arguments对象有一个callee属性，指向arguments对象所在的函数的指针

```
function factorial(num) {
	if(num <= 1) {
		return 1
	}else {
		return num * factorial(num - 1)
	}
}
// 改写，这样可以让函数逻辑和函数名解耦
function factorial(num) {
	if(num <= 1) {
		return 1
	}else {
		return num * arguments.callee(num - 1)
	}
}
```

