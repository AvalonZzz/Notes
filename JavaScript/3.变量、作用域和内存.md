# 变量、作用域和内存

## 原始值和引用值

> 保存原始值的变量是按值访问的
>
> 保存引用值的变量是按引用访问的

### 复制值

复制原始值会创建一个副本，并且把副本赋值给新的变量，两个变量**互不干扰**

引用值复制的时候,复制的其实是值的指针,此时两个变量的指针指向同一个内存地址,所以这两个变量是**互相映射的**

### 传递参数

`ECMAScript`的函数参数都是按值传递的,变量访问有按值访问和按引用访问之分

```js
function setName(obj){
	obj.name = "zzz";
}
let person = new Object();
setName(person)
console.log(person.name); // 'zzz',函数参数是按值传递的,所以obj的值是一个地址的复制值,但是修改和访问引用变量时是按引用访问的,所以修改后还是会映射到原有值
function setName(obj){
	obj.name = 'zzz'
	obj = new Object();
	obj.name = 'zcw'
}
let person = new Object();
setName(person)
console.log(person.name); // 'zzz',如果函数传参是按引用传递的,那么修改obj的值时,会映射到变量person的值,但实际没有影响,所以函数传参是按值传递的
```

### `instanceof`

此操作符会根据变量的原型链的类型来判断出结果

```js
person instanceof Object; // person变量是Object类型吗?
colors instanceof Array; // colors变量时Array类型吗?
```

## 执行上下文和作用域

每个上下文都有一个变量对象，上下文中定义的变量和函数都存在这个变量对象上

全局上下文是最外层的上下文,执行上下文在其所有代码都执行完毕后会被销毁

当代码执行流进入函数时,函数的上下文会被推到上下文栈中。函数执行完后,上下文栈将函数上下文弹出,控制权返还给之前的执行上下文

上下文中的代码执行的时候,会创建变量对象的作用于链(决定了各级上下文中的代码在访问变量和函数时的顺序)。函数上下文的活动对象(初始值只有arguments对象)作为其变量对象

> 函数参数被认为是当前上下文的变量

### 作用域链增强

作用域链增强是在作用域链的前端增加一个临时的变量对象,这个变量对象会在代码执行完毕后删除,以下这两种情况会出现这个现象:

- `try/catch`语句的`catch`块:在作用域链前端添加`catch`块的错误对象
- `with`语句:在作用域链的前端添加指定的对象

### 变量声明

#### 使用`var`的函数作用域变量声明

- 用`var`声明的变量,会被添加到最近的执行上下文的变量对象上,没用`var`声明就使用的变量会被添加到全局作用域
- `var`声明的变量会被提升到作用域头部

#### 使用`let`的块级作用域声明变量

- 用`let`声明的变量的作用域是块级的,由最近的一对`{}`界定
- 同一个作用域用`let`不能声明同名变量

#### 使用`const`的常量声明

- 用`const`声明变量时必须同时初始化,且一经声明就不能修改
- `let`的原则`const`也要遵守

## 垃圾回收

### 标记清除

如果变量所在的执行上下文在执行栈中,则该变量标记为引用状态,其他标记为清除状态,清除状态的变量就能被清除

###  引用计数

记录值被引用的次数,如果引用次数为0,则可回收

###  内存管理

1. 全局变量在用不着的时候需要手动将其解除引用
2. 使用`let`和`const`声明的变量能让变量尽早的被垃圾回收
3. 创建对象时一次性声明所有属性,不要的属性不要`delete`,将其设置为null（因为隐藏类可以提升性能）