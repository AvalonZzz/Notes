## 异步编程

### 同步与异步

同步行为每条指令都会按照他们出现的顺序

异步操作类似于系统中断，即当前进程外部的实体可以触发代码执行

### 以往的异步编程模式

早期异步编程使用回调函数来解决，但多个异步操作串联会造成回调地狱

```js
// 回调模式的失败处理
function double(value, success, failure) {
	setTimeout(() => {
		try{
			if (typeof value !== 'number') {
                throw 'Must provide number as first argument'
            }
            success(2*value)
		}catch(e){
            failure(e)
        }
	})
}
const successCallback = (x) => console.log(`Success: ${x}`)
const failureCallback = (e) => console.log(`Failure: ${e}`)
double(3, successCallback, failureCallback) //Success: 6
double('b', successCallback, failureCallback) // Failure: Must provide number as first argument
```

## 期约

### 期约基础

创建期约实例，需要传入执行器函数作为参数

```js
let p = new Promise(() => {})
setTimeout(console.log, 0 , p) // Promise <pending> 
```

#### 期约的状态

期约有三种状态：

- 待定（pending）
- 兑现（fulfilled，也成为解决resolved）
- 拒绝（rejected）

待定是最初状态，可落定为兑现或拒绝状态，一旦落定状态就不可逆。  

期约的状态是私有的，不能被外部JavaScript检测到，期约的状态也不能被外部JavaScript代码修改。这样是为了把异步行为封装起来，从而隔离外部的同步代码。  

#### 通过执行函数控制期约状态

执行器函数主要有两个职责：初始化期约的异步行为和控制状态的最终转换，状态的转换是通过resolve()和reject()两个函数参数来实现的

```js
let p1 = new Promise((resolve, reject) => resolve())
setTimeout(console.log, 0, p1) // Promise <resolved>

let p2 = new Promise((resolve, reject) => reject())
setTimeout(console.log, 0, p2) // Promise <rejected>
```

*执行器函数是同步执行的*

```js
new Promise(() => setTimeout(console.log, 0, 'executor'))
setTimeout(console.log, 0, 'promise initialized')
// executor
// promise initialized
```

*修改完状态就不可撤销了，继续修改状态会静默失败，所以可以通过setTimeout设置一个无论如何都会拒绝期约的回调，如果之前已修改成功，则定时器不会再修改状态为失败了*

```js
let p = new Promise((resolve, reject) => {
	resolve()
	reject() // 没有效果
})
setTimeout(console.log, 0, p) // Promise <resolved>

let p = new Promise((resolve, reject) => {
    setTimeout(reject, 10000) // 10s后调用reject()
    // 执行函数的逻辑
})
setTimeout(console.log, 0, p); // Promise <pending> 
setTimeout(console.log, 11000, p); // 11 秒后再检查状态
```

#### Promise.resolve()

通过Promise.resolve()静态方法可以使期约一开始就处于落定状态

```js
let p1 = new Promise((resolve, reject) => resolve())
let p2 = Promise.resolve()
// 两者实际上是一样的
```

这个解决的期约的值对应Promise.resolve()的第一个参数，多余的参数会被忽略。这个静态方法可以使任何值转为期约

```js
setTimeout(console.log, 0, Promise.resolve()) // Promise <resolved>: undefined
setTimeout(console.log, 0, Promise.resolve(3)) // Promise <resolved>: 3
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)) // Promise <resolved>: 4
```

如果这个静态方法传入的参数本身是一个期约，那它的行为就类似于一个空包装。所以说Promise.resolve()是幂等方法

```js
let p = Promise.resolve(7)
setTimeout(console.log, 0, p === Promise.resolve(p)) // true
setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))) // true 
```

#### Promise.reject()

Promise.reject()会实例化一个拒绝的期约并抛出一个不能被try/catch捕获的异步错误

```js
let p = new Promise((resolve, reject) => reject())
let p2 = Promise.reject()
// 两者实际上作用一样的
```

拒绝的理由就是传给Promise.reject()的第一个参数。这个参数也会传给后续的拒绝处理程序

```js
let p = Promise.reject(3)
setTimeout(console.log, 0, p) // Promise <rejected>: 3

p.then(null, (e) => setTimeout(console.log, 0, e)) // 3
```

Promise.reject()没有幂等逻辑。如果传给它一个期约对象，则这个期约对象会成为它返回的拒绝理由

```js
setTimeout(console.log, 0, Promise.reject(Promise.resolve())) // Promise <rejected>: Promise <resolved>
```

### 期约的实例方法

实例方法可以访问异步操作返回的数据，处理期约成功和失败的结果，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。

#### Promise.prototype.then(

这个方法是给期约添加处理程序的主要方法。接收两个参数：onResolved处理程序和onRejected处理程序

```js
function onResolved(id) {
	setTimeout(console.log, 0, id, 'resolved')
}
function onRejected(id) {
	setTimeout(console.log, 0, id, 'rejected')
}

let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000))
let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000))
p1.then(() => onResolved('p1'),
        () => onRejected('p1'))
p2.then(() => onResolved('p2'),
        () => onRejected('p2'))
// p1 resolved
// p2 rejected
```

Promise.prototype.then()方法返回一个新的期约实例

*这个实例基于onResolved处理程序的返回值通过Promise.resolve()包装生成。如果没有这个处理程序，则Promise.resolve()就会包装上一个期约解决之后的值。如果没有显示返回语句，则Promise.resolve()会包装默认值undefined*

```js
let p1 = new Promise(() => {})
let p2 = p1.then()
setTimeout(console.log, 0, p1) // Promise <pending>
setTimeout(console.log, 0, p1) // Promise <pending>
setTimeout(console.log, 0, p1 === p2) // false
```

```js
let p1 = Promise.resolve('foo')
let p2 = p1.then() // 没有onResolved处理程序则把上一个结果调用Promise.resolve()
setTimeout(console.log, 0, p2) // Promise <resolved>: foo

// 这些都一样
let p3 = p1.then(() => undefined) // Promise <resolved>: undefined
let p4 = p1.then(() => {}) // Promise <resolved>: undefined
let p5 = p1.then(() => Promise.resolve()) // Promise <resolved>: undefined

// 这些都一样
let p6 = p1.then(() => 'bar') // Promise <resolved>: bar
let p7 = p1.then(() => Promise.resolve('bar')) // Promise <resolved>: bar
```

抛出异常会返回拒绝的期约，但是返回错误对象返回的是解决的期约，因为错误对象包装在一个解决的期约中

```js
let p10 = p1.then(() =>  {throw 'baz'})
setTimeout(console.log, 0, p10) // Promise <rejected> baz

let p11 = p1.then(() => Error('qux'))
setTimeout(console.log, 0, p11) // Promise <resolved>: Error: qux
```

onRejected处理程序与上面类似，返回值也会被Promise.resolve()包装

```js
let p1 = Promise.rejeect('foo')
let p2 = p1.then()
setTimeout(console.log, 0, p2) // Promise <rejected>: foo

let p3 = p1.then(null, () => undefined) // Promise <resolved>: undefined
let p4 = p1.then(null, () => {}) // Promise <resolved>: undefined
let p5 = p1.then(null, () => Promise.reject()) // Promise <resolved>: undefined

let p6 = p1.then(null, () => 'bar') // Promise <resolved>: bar
let p7 = p1.then(null, () => Promise.resolve('bar')) // Promise <resolved>: bar

let p10 = p1.then(null, () => {throw 'baz'}) // Promise <rejected>: baz
let p11 = p1.then(null, () => Error('qux')) // Promise <resolved>: Error: qux
```

#### Promise.prototype.catch()

这个方法用于给期约添加拒绝处理程序。只接受一个参数：onRejected处理程序。相当于Promise.prototype.then(null, onRejected)的语法糖

```js
let p = Promise.reject()
let onRejected = function(e) {
	setTimeout(console.log, 0, 'rejected')
}
// 以下两种添加拒绝处理程序的方法是一样的
p.then(null, onRejected) // rejected
p.catch(onRejected) // rejected
```

Promise.prototype.catch()返回一个新的期约实例，行为和Promise.prototype.then()的onRejected处理程序一样

```js
let p1 = new Promise(() => {})
let p2 = p1.catch()
setTimeout(console.log, 0, p1) // Promise <pending>
setTimeout(console.log, 0, p1) // Promise <pending>
setTimeout(console.log, 0, p1 === p2) // false
```

#### Promise.prototype.finally()

这个方法给期约添加onFinally处理程序，这个程序在期约转换为解决或拒绝状态都会执行

```js
let p1 = Promise.resolve()
let p2 = Promise.reject()
let onFinally = function() {
	setTimeout(console.log, 0, 'Finally')
}
p1.finally(onFinally) // Finally
p2.finally(onFinally) // Finally
```

Promise.prototype.finally()方法返回一个新的期约实例

```js
let p1 = new Promise(() => {})
let p2 = p1.finally()
setTimeout(console.log, 0, p1) // Promise <pending>
setTimeout(console.log, 0, p2) // Promise <pending>
setTimeout(console.log, 0, p1 === p2) // false
```

这个新期约大多数情况下表现为父期约的传递

```js
let p1 = Promise.resolve('foo')
// 以下都会原样往后传递
let p2 = p1.finally() // Promise <resolved>: foo
let p3 = p1.finally(() => undefined) // Promise <resolved>: foo
let p4 = p1.finally(() => {}) // Promise <resolved>: foo
let p5 = p1.finally(() => Promise.resolve()) // Promise <resolved>: foo
let p6 = p1.finally(() => 'bar') // Promise <resolved>: foo
let p7 = p1.finally(() => Promise.resolve('bar')) // Promise <resolved>: foo
let p8 = p1.finally(() => Error('qux')) // Promise <resolved>: foo
```

如果onFinally处理程序返回的是一个待定的期约或者onFinally处理程序抛出了错误(显式抛出或返回拒绝期约)，则会返回相应的期约

```js
let p9 = p1.finally(() => new Promise(() => {})) // Promise <pending>
let p10 = p1.finally(() => Promise.reject()) // Promise <rejected>: undefined
let p11 = p1.finally(() => throw 'baz') // Promise <rejected>: baz
```

#### 非重入期约方法

非重入特性：当期约进入落定状态，与该状态的处理程序仅仅只是被排期，跟在这个处理程序之后的同步代码一定先执行

```js
let p = Promise.resolve()
p.then(() => console.log('onResolved handler'))
console.log('then() returns')
// 输出
// then() return s
// onResolved handler
// 在一个解决期约上调用then，会把then的处理程序推进消息队列，但这个处理程序一定在当前线程上的同步代码执行完成后执行
```

非重入特性适用于onResolved/onRejected处理程序、catch处理程序和finally处理程序

```js
let p1 = Promise.resolve()
p1.then(() => console.log('p1.then() onResolved'))
console.log('p1.then() returns')

let p2 = Promise.reject()
p2then(null, () => console.log('p2.then() onRejected'))
console.log('p2.then() returns')

let p3 = Promise.reject()
p3.catch(() => console.log('p3.catch() onRejected'))
console.log('p3.catch() returns')

let p4 = Promise.resolve()
p4.finally(() => console.log('p4.finally() onFinally'))
console.log('p4.finally() returns')
// 执行顺序
// p1.then() returns
// p2.then() returns
// p3.then() returns
// p4.then() returns
// p1.then() onResolved
// p2.then() onRejected
// p3.catch() onRejected
// p4.finally() onFinally
```

#### 邻近处理程序的执行顺序

如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加他们的顺序一次执行

```js
let p1 = Promise.resolve(); 
let p2 = Promise.reject(); 
p1.then(() => setTimeout(console.log, 0, 1)); 
p1.then(() => setTimeout(console.log, 0, 2)); 
// 1 
// 2 
p2.then(null, () => setTimeout(console.log, 0, 3)); 
p2.then(null, () => setTimeout(console.log, 0, 4)); 
// 3 
// 4 
p2.catch(() => setTimeout(console.log, 0, 5)); 
p2.catch(() => setTimeout(console.log, 0, 6)); 
// 5 
// 6 
p1.finally(() => setTimeout(console.log, 0, 7)); 
p1.finally(() => setTimeout(console.log, 0, 8)); 
// 7 
// 8 
```

#### 传递解决值和拒绝理由

到了落定状态，期约会提供解决值或拒绝理由给相关处理函数

```js
let p1 = new Promise((resolve, reject) => resolve('foo'))
p1.then((value) => console.log(value)) // foo
let p1 = new Promise((resovle, reject) => reject('bar'))
p2.then(null, (reason) => console.log(reason)) // bar
let p3 = Promise.resolve('foo')
p3.then((value) => console.log(value)) // foo
let p4 = Promise.reject('bar')
p4.then(null, (reason) => console.log(reason)) // bar
```

### 期约连锁和期约合成

期约组合的方式:

- 期约连锁:一个期约接一个期约的拼接
- 期约合成:将多个期约合为一个期约

#### 期约连锁

每个期约的实例方法都会返回一个新的期约对象,这个新的期约对象又有自己的实例方法,以连缀的方法调用就构成期约连锁

```js
let p = new Promise((resolve, reject) => {
	console.log('first')
	resolve()
})
p.then(() => console.log('second'))
 .then(() => console.log('third'))
 .then(() => console.log('fourth'))
// first
// second
// third
// fourth

// 真正执行异步任务,串化异步任务
let p1 = new Promise((resolve, reject) => {
    console.log('p1 executor')
    setTimeout(resolve, 1000)
})
p1.then(() => new Promise((resolve,reject) => {
    console.log('p2 executor')
    setTimeout(resolve, 1000)
}))
    .then(() => new Promise((resolve,reject) => {
    console.log('p3 exector')
    setTimeout(resolve, 1000)
}))
    .then(() => new Promise((resolve, reject) => {
    console.log('p4 exector')
    setTimeout(resolve, 1000)
}))
// p1 executor（1 秒后）
// p2 executor（2 秒后）
// p3 executor（3 秒后）
// p4 executor（4 秒后）
```

#### 期约合成

Promise类提供两个将多个期约实例合成一个期约的静态方法:`Promise.all()`和`Promise.race()`

##### `Promise.all()`

`Promise.all()`创建的期约会在一组期约全部解决之后再解决,接收一个可迭代对象,返回一个新的期约

```js
let p1 = Promise.all([
Promise.resolve(),
Promise.resolve()
])
let p2 = Promise.all([3,4]) // 可迭代对象中的元素会通过Promise.resolve()转换为期约
let p3 = Promise.all([]) // 空的可迭代对象等价于Promise.resolve()
```

合成的期约只会再每个包含的期约都解决之后才会解决

```js
let p = Promise.all([
    Promise.resolve(),
    new Promise((resolve, reject) => setTimeout(resolve, 1000))
])
setTimeout(console.log, 0, p)
p.then(() => setTimeout(console.log, 0, 'all() resolved'))
// 打印顺序
// Promise <pending>
// all() resolved 1秒后
```

`Promise.all()`包含的期约只要有一个待定则合成的期约也待定,只要有一个包含的期约拒绝,则合成的期约也拒绝,且第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由

```js
let p1 = Promise.all([new Promise(() => {})])
setTimeout(console.log, 0, p1) // 永远都是Promise <pending>状态

let p2 = Promise.all([
    Promise.resolve(),
    Promise.reject(),
    Promise.resolve()
])
setTimeout(console.log, 0, p2) // Promise <rejected>

let p = Promise.all([
    Promise.reject(3),
    new Promise((resolve, reject) => setTimeout(reject, 1000))
])
p.catch((reason) => setTimeout(console.log, 0, reason)) // 3,第一个拒绝的理由是3
```

##### `Promise.race()`

`Promise.race()`接收一组期约集合的可迭代对象,返回最先解决或拒绝的期约的镜像

```js
    let p1 = Promise.race([3,4 ])
    setTimeout(console.log, 0, p1) // Promise <resolved>: 3可迭代对象中的元素会通过Promise.resolve()转换为期约

    let p2 = Promise.race([])
    setTimeout(console.log, 0 ,p2) // Promise <pending> 空的可迭代对象等价于new Promise(() => {})
```

`Promise.rece()`包含的期约中第一个拒绝的会成为合成期约的拒绝理由

```js
let p = Promise.race([
    Promise.reject(3),
    new Promise((resolve,reject) => {setTimeout(reject, 1000)})
])
p.catch((reason) => setTimeout(console.log, 0, reason)) // 3
```

### 期约扩展

#### 期约取消

```html
<button id="start">start</button>
<button id="cancel">cancel</button>
```

```js
class CancelToken{
    constructor(cancelFn){
        this.promise = new Promise((resolve, rejcet) => {
            cancelFn(() => {
                console.log(1111)
                setTimeout(console.log, 0, 'delay cancelled')
                resolve()
            })
        })
    }
}

const startButton = document.querySelector('#start')
const cancelButton = document.querySelector('#cancel')

function cancelableDelayedResolve(delay) {
	setTimeout(console.log, 0, 'set delay')

    return new Promise((resolve, reject) => {
        const id = setTimeout(() => {
            setTimeout(console.log, 0, 'delayed resolve')
            resolve()
        }, delay)
        console.log(2222)
        const cancelToken = new CancelToken((cancelCallback) => {
            console.log(3333)
            cancelButton.addEventListener('click', cancelCallback)
        })
        cancelToken.promise.then(() => clearTimeout(id))
    })
}


startButton.addEventListener('click', () => cancelableDelayedResolve(1000))
```

#### 期约进度通知

// TODO
