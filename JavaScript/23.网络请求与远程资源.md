## 

## XMLHttpRequest对象

创建XHR对象`let xhr = new XMLHttpRequest()`

### 使用XHR

使用XHR对象首先要调用open（）方法，，接收三个参数：method、url和是否异步请求的布尔值

调用open（）方法不会发送请求，只是会发送请求做好准备

```js
xhr.open('get', 'example.php', false)
```

要想发送请求需要调用send（）方法，接收一个参数：发送的请求体数据，如果没有请求体，必须传null。send（）方法调用后，请求就会发送到服务器

```js
xhr.open("get", "example.txt", false);
xhr.send(null);
```

上面这个请求是同步的，所有js代码会在服务器响应后继续执行。

收到响应后，XHR对象的以下属性会被填充上数据：

- responseText：作为响应体返回的数据
- responseXML：响应的内容类型时"text/xml"或"application/xml"，那么包含响应数据的XML DOM文档，非XML数据是null
- status：响应的HTTP状态
- statusText：响应的HTTP状态描述

当status为2开头的状态码或者304（表示资源未修改过，从浏览器缓存中拿）时，响应才是成功返回的

```js
xhr.open("get", "example.txt", false);
xhr.send(null);

if(xhr.status>=200 && xhr.status<300 || xhr.status===304){
    alert(xhr.reponseText)
}else {
    alert('Request was unsuccessful:'+xhr.status)
}
```

当发送异步请求的时候，需要用到XHR的readyState属性，且readyState属性改变会触发readyStatechange事件

- 0：未初始化。尚未调用open()方法
- 1：已打开。已调用open（）方法，尚未调用send（）方法
- 2：已发送。已调用send（）方法，尚未收到响应
- 3：接收中。已经收到部分响应
- 4：完成。已经收到所有响应

```js
let xhr = new XMLHttpRequest()
xhr.onreadyStatechange = function(){
	if(xhr.readyState === 4){
		if(xhr.status>=200&&xhr.status<300||xhr.status===304){
			alert(xhr.responseText)
		}else{
			alert('Request was unsuccessful:'+xhr.status)
		}
	}
}
xhr.open('get', 'example.php', true)
xhr.send(null)
```

在收到响应之前可以通过abort()方法取消异步请求

```js
xhr.abort()
```

### HTTP头部



## WebSocket

WebSocket是通过一个长时连接实现与服务器全双工、双向的通信。再JavaScript中创建WebSocket时，一个HTTP请求会发送到服务器以初始化连接。服务器响应后连接使用HTTP的Upgrade头部从HTTP协议切换到WebSocket协议。  

WebSocket使用了自定义协议，`ws://`是不安全的连接，`wss://`是安全的连接。

使用自定义协议的好处是客户端和服务器之间可以发送非常少的数据，更小的报数据让WebSocket非常适合带宽和延迟问题明显的移动应用。  

### API

创建WebSocket，就要实例化一个WebSocket对象并传入提供连接的绝对URL，*同源策略不适用于WebSocket，因此可以打开任何站点的连接*。至于是否与来自特定源的页面通信，则完全取决于服务器。（在握手阶段可以确定请求来自哪里）

```js
let socket = new WebSocket('ws://www.example.com/server.php')
```

浏览器会在初始化WebSocket对象后立即创建连接。和XHR类似，WebSocket也有一个readyState属性表示当前状态，但没有readyStatechange事件，而是有与上述不同状态对应的其他事件

- WebSocket.OPENING(0)：连接正在建立
- WebSocket.OPEN(1)：连接已经建立
- WebSocket.CLOSING(2)：连接正在关闭
- WebSocket.CLOSE(3)：连接已经关闭

任何时候都可以调用close()方法关闭WebSocket连接，调用之后，readyState立即变为2，并在关闭后变为3

```js
socket.close()
```

### 发送和接收数据

`send(字符串/ArrayBuffer/Blob)`方法向服务器发送数据

```js
let socket = new WebSocket('ws://www.example.com/server.php')
let stringData = 'hello world'
let arrayBufferData = Uint8Array.from(['f', 'o', 'o'])
let blobData = new Blob(['f', 'o', 'o'])
socket.send(stringData)
socket.send(arrayBufferData.buffer)
socket.send(blobData)
```

服务器向客户端发送消息时，WebSocket对象上会触发message事件。可通过`event.data`属性访问到有效载荷，`event.data`返回的数据可能是ArrayBuffer或Blob，由WebSocket对象的binaryType属性决定，值可能是'blob'或'arraybuffer'

```js
socket.onmessage = function(event) {
    let data = event.data
    // 对数据执行某些操作
}
```

### 其他事件

WebSocket对象有3个生命周期函数：

- open：在连接成功建立时触发
- error：在发生错误时触发。连接无法存续
- close：在连接关闭时触发

WebSocket对象不支持DOM Level2事件监听方式，所以只能用DOM Level0的风格来监听这些事件

只有close事件的event对象上有额外信息，这个对象有3个额外属性：wasClean（布尔值，表示连接是否干净的关闭）、code（来自服务器的数值状态码）、reason（字符串，包含服务器发来的消息）

```js
let socket = new WebSocket('ws://www.example.com/server.php')
socket.onopen = function(){
    alert('connection established')
}
socket.onerror = function(){
    alert('connection error')
}
socket.onclose = function(event){
    alert('connection closed')
    console.log(`as clean?${event.wasClean} Code=${event.code} Reason=${event.readon}`)
}
```

